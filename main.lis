1     0000              MODULE cpm_crt0_asm
2     0000              LINE 0, "/home/ed/dev/3rdparty/z88dk/lib/config/../..//lib/target/cpm/classic/cpm_crt0.asm"
0     0000              
1     0000              ;
2     0000              ;       Startup for CP/M
3     0000              ;
4     0000              ;       Stefano Bodrato - Apr. 2000
5     0000              ;                         Apr. 2001: Added MS-DOS protection
6     0000              ;
7     0000              ;	Dominic Morris  - Jan. 2001: Added argc/argv support
8     0000              ;			- Jan. 2001: Added in malloc routines
9     0000              ;			- Jan. 2001: File support added
10    0000              ;
11    0000              ;       $Id: cpm_crt0.asm,v 1.43 2016-10-31 16:16:33 stefano Exp $
12    0000              ;
13    0000              ; 	There are a couple of #pragma commands which affect
14    0000              ;	this file:
15    0000              ;
16    0000              ;	#pragma output noprotectmsdos - strip the MS-DOS protection header
17    0000              ;	#pragma output protect8080 - add a check to block the program when on an 8080 CPU (not compatible)
18    0000              ;
19    0000              
20    0000                  MODULE  cpm_crt0
21    0000              
22    0000                  defc    crt0 = 1
23    0000                  INCLUDE "zcc_opt.def"
1     0000              
24    0000              
25    0000              
26    0000              
27    0000                  EXTERN	cpm_platform_init
28    0000                  EXTERN    _main		;main() is always external to crt0
29    0000              
30    0000                  PUBLIC    cleanup		;jp'd to by exit()
31    0000                  PUBLIC    l_dcal		;jp(hl)
32    0000              
33    0000                  defc    TAR__clib_exit_stack_size = 32
34    0000                  defc    TAR__register_sp = -1
35    0000                  defc	__CPU_CLOCK = 4000000
36    0000              
37    0000                  IF !DEFINED_CRT_ORG_CODE
38    0000                      defc    CRT_ORG_CODE  = $100
39    0000                  ENDIF
40    0000              
41    0000                  IF !DEFINED_CLIB_OPEN_MAX
42    0000                      defc    DEFINED_CLIB_OPEN_MAX = 1
43    0000                      defc    CLIB_OPEN_MAX = 3
44    0000                  ENDIF
45    0000              
46    0000                  ; Default to some "sensible" values
47    0000                  IF !DEFINED_CONSOLE_ROWS
48    0000                      defc    CONSOLE_ROWS = 24
49    0000                  ENDIF
50    0000                  IF !DEFINED_CONSOLE_COLUMNS
51    0000                      defc    CONSOLE_COLUMNS = 80
52    0000                  ENDIF
53    0000              
54    0000                  INCLUDE "crt/classic/crt_rules.inc"
1     0000              
2     0000              ; Rules for setting up defaults for configuring the build
3     0000              
4     0000              
5     0000                 IFNDEF CRT_INITIALIZE_BSS
6     0000                    defc CRT_INITIALIZE_BSS = 1
7     0000                 ENDIF
8     0000              
9     0000                 IFDEF REGISTER_SP
10    0000                    defc __register_sp = REGISTER_SP
11    0000                 ELSE
12    0000                    IFDEF STACKPTR
13    0000                       defc __register_sp = STACKPTR
14    0000                    ELSE
15    0000                       IFDEF TAR__register_sp
16    0000                          defc __register_sp = TAR__register_sp
17    0000                       ELSE
18    0000                          defc __register_sp = DEF__register_sp
19    0000                       ENDIF
20    0000                    ENDIF
21    0000                 ENDIF
22    0000              
23    0000                 IFNDEF TAR__crt_enable_rst
24    0000                     defc TAR__crt_enable_rst = 0x0000
25    0000                 ENDIF
26    0000              
27    0000                 IFDEF CRT_ENABLE_RST
28    0000                    defc __crt_enable_rst = CRT_ENABLE_RST | TAR__crt_enable_rst
29    0000                 ELSE
30    0000                    defc __crt_enable_rst = TAR__crt_enable_rst
31    0000                 ENDIF
32    0000              
33    0000                 IFDEF CRT_ENABLE_NMI
34    0000                    defc __crt_enable_nmi = CRT_ENABLE_NMI
35    0000                 ELSE
36    0000                   IFNDEF TAR__crt_enable_nmi
37    0000                      defc TAR__crt_enable_nmi = 0
38    0000                   ENDIF
39    0000                   defc __crt_enable_nmi = TAR__crt_enable_nmi
40    0000                 ENDIF
41    0000              
42    0000                 ; By default we want to have stdio working for us
43    0000                 IFNDEF CRT_ENABLE_STDIO
44    0000                     defc CRT_ENABLE_STDIO = 1
45    0000                 ENDIF
46    0000              
47    0000                 IFDEF CLIB_EXIT_STACK_SIZE
48    0000                    defc __clib_exit_stack_size = CLIB_EXIT_STACK_SIZE
49    0000                 ELSE
50    0000                    IFDEF TAR__clib_exit_stack_size
51    0000                       defc __clib_exit_stack_size = TAR__clib_exit_stack_size
52    0000                    ELSE
53    0000                       defc __clib_exit_stack_size = DEF__clib_exit_stack_size
54    0000                    ENDIF
55    0000                 ENDIF
56    0000              
57    0000                 ; For each bank call we save 2 words on the temporary stack
58    0000                 ; this controls the depth of calls we can make safely
59    0000                 IFNDEF CLIB_BANKING_STACK_SIZE
60    0000                    PUBLIC CLIB_BANKING_STACK_SIZE
61    0000                    IFDEF TAR__clib_banking_stack_size
62    0000                       defc CLIB_BANKING_STACK_SIZE = TAR__clib_banking_stack_size
63    0000                    ELSE
64    0000                       defc CLIB_BANKING_STACK_SIZE = 100
65    0000                    ENDIF
66    0000                 ENDIF
67    0000              
68    0000              
69    0000                 PUBLIC __CRT_KEY_DEL
70    0000                 IFDEF CRT_KEY_DEL
71    0000                   defc __CRT_KEY_DEL = CRT_KEY_DEL
72    0000                 ELSE
73    0000                   defc __CRT_KEY_DEL = 8
74    0000                 ENDIF
75    0000              
76    0000                 PUBLIC __CRT_KEY_CAPS_LOCK
77    0000                 IFDEF CRT_KEY_CAPS_LOCK
78    0000                   defc __CRT_KEY_CAPS_LOCK  = CRT_KEY_CAPS_LOCK
79    0000                 ELSE
80    0000                   defc __CRT_KEY_CAPS_LOCK = 6
81    0000                 ENDIF
82    0000              
83    0000                 PUBLIC __CPU_CLOCK
84    0000                 IFNDEF __CPU_CLOCK
85    0000                   defc __CPU_CLOCK = 3500000
86    0000                 ENDIF
87    0000              
88    0000                 PUBLIC __CLIB_CONIO_NATIVE_COLOUR
89    0000                 IFDEF CLIB_CONIO_NATIVE_COLOUR
90    0000                   defc __CLIB_CONIO_NATIVE_COLOUR = CLIB_CONIO_NATIVE_COLOUR
91    0000                 ELSE
92    0000                   defc __CLIB_CONIO_NATIVE_COLOUR = 0
93    0000                 ENDIF
94    0000              
95    0000                 ; When using the firmware printer we may need to disable the soft
96    0000                 ; cursor created by fgets_cons()
97    0000                 PUBLIC __CLIB_DISABLE_FGETS_CURSOR
98    0000                 IFDEF CLIB_DISABLE_FGETS_CURSOR
99    0000                   defc __CLIB_DISABLE_FGETS_CURSOR = CLIB_DISABLE_FGETS_CURSOR
100   0000                 ELSE
101   0000                   defc __CLIB_DISABLE_FGETS_CURSOR = 0
102   0000                 ENDIF
103   0000              
104   0000                 ; Delay when entering fgetc_cons()
105   0000                 ; 50ms stops rogue repeats nicely, but may need tuning
106   0000                 PUBLIC __CLIB_FGETC_CONS_DELAY
107   0000                 IFDEF CLIB_FGETC_CONS_DELAY
108   0000                   defc __CLIB_FGETC_CONS_DELAY = CLIB_FGETC_CONS_DELAY
109   0000                 ELSE
110   0000                   defc __CLIB_FGETC_CONS_DELAY = 50
111   0000                 ENDIF
112   0000              
113   0000                 ; Delay when kbhit/getch() returns a cached key press
114   0000                 ; Delaying slightly means that typing is possible
115   0000                 PUBLIC __CLIB_KBHIT_DELAY
116   0000                 IFDEF CLIB_KBHIT_DELAY
117   0000                   defc __CLIB_KBHIT_DELAY = CLIB_KBHIT_DELAY
118   0000                 ELSE
119   0000                   defc __CLIB_KBHIT_DELAY = 0
120   0000                 ENDIF
121   0000              
122   0000                 ; Some ports (looking at you tiki100) need to have graphics routines stored out
123   0000                 ; of paging harm. Normally we'd just use code_driver and keep the routines close
124   0000                 ; the start of the address space. However for tiki100, we need them at the end,
125   0000                 ; (in this case > 32768)
126   0000                 IF DEFINED_CRT_ORG_GRAPHICS
127   0000                     defc __crt_org_graphics = CRT_ORG_GRAPHICS
128   0000                 ENDIF
129   0000              
130   0000                 ; If 32 bit floats are defined, then we need to indicate to the library
131   0000                 ; that they are in use (mainly for printf/scanf)
132   0000                 PUBLIC CLIB_32BIT_FLOATS
133   0000                 IF !DEFINED_CLIB_32BIT_FLOATS
134   0000                     defc CLIB_32BIT_FLOATS = 0
135   0000                 ENDIF
136   0000                 PUBLIC CLIB_64BIT_FLOATS
137   0000                 IF !DEFINED_CLIB_64BIT_FLOATS
138   0000                     defc CLIB_64BIT_FLOATS = 0
139   0000                 ENDIF
140   0000              
141   0000                 ; Some targets startup in different screen modes depending on the environment:
142   0000                 ; eg native = 40columns, CP/M = 80 columns. These should be explicitly defined
143   0000                 ; if needed. So default to an unused value if not
144   0000                 PUBLIC CLIB_DEFAULT_SCREEN_MODE
145   0000                 IFNDEF CLIB_DEFAULT_SCREEN_MODE
146   0000                     defc CLIB_DEFAULT_SCREEN_MODE = 0
147   0000                 ENDIF
148   0000              
149   0000                  ; Maximum number of FILEs available
150   0000                  IF !DEFINED_CLIB_FOPEN_MAX
151   0000                      DEFC    CLIB_FOPEN_MAX = 10
152   0000                  ENDIF
153   0000                  PUBLIC  __FOPEN_MAX
154   0000                  defc    __FOPEN_MAX = CLIB_FOPEN_MAX
155   0000              
156   0000                  ; Maximum number of fds available
157   0000                  IF !DEFINED_CLIB_OPEN_MAX
158   0000                      ; Map this old nofileio pragma into a modern form
159   0000                      IF DEFINED_nofileio
160   0000                          defc    CLIB_OPEN_MAX = 0
161   0000                      ELSE
162   0000                          defc    CLIB_OPEN_MAX = CLIB_FOPEN_MAX
163   0000                      ENDIF
164   0000                  ENDIF
165   0000                  PUBLIC  __CLIB_OPEN_MAX
166   0000                  defc    __CLIB_OPEN_MAX = CLIB_OPEN_MAX
167   0000              
168   0000                 ; By default allow the command line options if available on the target/subtype
169   0000                 IF !DEFINED_CRT_ENABLE_COMMANDLINE
170   0000                    IFDEF TAR__CRT_ENABLE_COMMANDLINE
171   0000                        defc CRT_ENABLE_COMMANDLINE = TAR__CRT_ENABLE_COMMANDLINE
172   0000                    ELSE
173   0000                        defc CRT_ENABLE_COMMANDLINE = 1
174   0000                    ENDIF
175   0000                 ENDIF
176   0000              
177   0000              
178   0000                 ; Map this old pragma into a "modern" name
179   0000                 IF DEFINED_nostreams
180   0000                     defc CRT_COMMANDLINE_REDIRECTION = 0
181   0000                 ELIF !DEFINED_CRT_COMMANDLINE_REDIRECTION
182   0000                     ; File redirection on command line arguments can only happen
183   0000                     ; if stdio is enabled
184   0000                     IF CRT_ENABLE_STDIO = 1
185   0000                         defc CRT_COMMANDLINE_REDIRECTION = 1
186   0000                     ELSE
187   0000                         defc CRT_COMMANDLINE_REDIRECTION = 0
188   0000                     ENDIF
189   0000                 ENDIF
190   0000              
191   0000                 ; Block size for the gendos library
192   0000                 IF !DEFINED_CLIB_RND_BLOCKSIZE
193   0000                    DEFC    CLIB_RND_BLOCKSIZE = 1000
194   0000                 ENDIF
195   0000                 PUBLIC  __RND_BLOCKSIZE
196   0000                 defc    __RND_BLOCKSIZE = CLIB_RND_BLOCKSIZE
197   0000              
198   0000                 ; Define the height of the font
199   0000                 IF !DEFINED_CLIB_FONT_HEIGHT
200   0000                    defc CLIB_FONT_HEIGHT = 8
201   0000                 ENDIF
202   0000                 PUBLIC __CLIB_FONT_HEIGHT
203   0000                 defc __CLIB_FONT_HEIGHT = CLIB_FONT_HEIGHT
204   0000              
205   0000                 ; Custom memory map
206   0000                 IF DEFINED_MMAP
207   0000                     defc __MMAP = MMAP
208   0000                 ELSE
209   0000                     defc __MMAP = 0
210   0000                 ENDIF
211   0000              
55    0000              
56    0000                  org     CRT_ORG_CODE
57    0000              
58    0000              
59    0000              ;----------------------
60    0000              ; Execution starts here
61    0000              ;----------------------
62    0000              start:
63    0000              IF !DEFINED_noprotectmsdos
64    0000  EB 04       	defb	$eb,$04		;DOS protection... JMPS LABE
65    0002  EB          	ex	de,hl
66    0003  C3 34 01    	jp	begin-start+$100
67    0006  B4 09       	defb	$b4,$09		;DOS protection... MOV AH,9
68    0008  BA          	defb	$ba
69    0009  0F 00       	defw	dosmessage	;DOS protection... MOV DX,OFFSET dosmessage
70    000B  CD 21       	defb	$cd,$21		;DOS protection... INT 21h.
71    000D  CD 20       	defb	$cd,$20		;DOS protection... INT 20h.
72    000F              
73    000F              dosmessage:
74    000F  54 68 69 73 20 70 72 6F 67 72 61 6D 20 69 73 20 66 6F 72 20 61 20 43 50 2F 4D 20 73 79 73 74 65 
      002F  6D 2E 
                        	defm	"This program is for a CP/M system."
75    0031  0D 0A 24    	defb	13,10,'$'
76    0034              
77    0034              begin:
78    0034              ENDIF
79    0034              
80    0034              IF DEFINED_protect8080
81    0034              
82    0034              	ld	a,$7F			; 01111111 into accumulator
83    0034              	inc	a			; make it overflow ie. 10000000
84    0034              	jp	pe,isz80	; only 8080 resets for odd parity here
85    0034              
86    0034              	ld	c,9		; print string
87    0034              	ld	de,err8080
88    0034              	call	5	; BDOS
89    0034              	jp	0
90    0034              
91    0034              err8080:
92    0034              	defm	"This program requires a Z80 CPU."
93    0034              	defb	13,10,'$'
94    0034              isz80:
95    0034              ENDIF
96    0034              
97    0034  00          	nop	 ;   Those extra bytes fix the Amstrad NC's ZCN support !!?!
98    0035  00          	nop
99    0036              
100   0036  21 00 00        ld      hl,0
101   0039  39              add     hl,sp
102   003A  22 0B 01        ld      (start1+1),hl	;Save entry stack
103   003D              IF (startup=3)
104   003D                  ; Increase to cover +3 MEM banking
105   003D                  defc    __clib_exit_stack_size_t  = __clib_exit_stack_size + 18 + 18
106   003D                  UNDEFINE __clib_exit_stack_size
107   003D                  defc    __clib_exit_stack_size = __clib_exit_stack_size_t
108   003D              ENDIF
109   003D                  INCLUDE "crt/classic/crt_init_sp.asm"
1     003D              IF __register_sp < -1
2     003D              
3     003D                 IF __CPU_INTEL__
4     003D                   ld hl,(-__register_sp)      ; stack location is stored at memory address
5     003D                   ld sp,hl
6     003D                 ELSE
7     003D                   ld sp,(-__register_sp)      ; stack location is stored at memory address
8     003D                 ENDIF
9     003D              
10    003D              ELSE
11    003D              
12    003D                 IF __register_sp != -1
13    003D              
14    003D                    ld sp,__register_sp      ; stack is at fixed address
15    003D              
16    003D                 ENDIF
17    003D              
18    003D              ENDIF
19    003D              
20    003D              
110   003D                  INCLUDE "crt/classic/crt_init_atexit.asm"
1     003D              
2     003D                  PUBLIC  __clib_exit_stack_size
3     003D              
4     003D              IF __clib_exit_stack_size > 0
5     003D  21 C0 FF        ld      hl, -(__clib_exit_stack_size * 2)
6     0040  39              add     hl,sp
7     0041  F9              ld      sp,hl
8     0042              ENDIF
9     0042              
10    0042              
111   0042  CD 00 00        call    crt0_init_bss
112   0045  CD 00 00        call    cpm_platform_init	;Any platform specific init
113   0048  21 00 00        ld      hl,0
114   004B  39              add     hl,sp
115   004C  22 66 00        ld      (exitsp),hl
116   004F              
117   004F              ; Memory banking for Spectrum +3
118   004F              IF (startup=3)
119   004F              	PUBLIC    p3_poke
120   004F              	PUBLIC    p3_peek
121   004F              
122   004F              	push hl
123   004F              	ld de,64
124   004F              	add hl,de
125   004F              	ld (p3_poke+1),hl
126   004F              	push hl
127   004F              	ld de,18
128   004F              	add hl,de
129   004F              	ld (p3_peek+1),hl
130   004F              	pop hl
131   004F              	ld d,h
132   004F              	ld e,l
133   004F              	ld hl,pokebyte_code
134   004F              	ld bc,18+18
135   004F              	ldir
136   004F              	pop hl
137   004F              ENDIF
138   004F              
139   004F              ; Optional definition for auto MALLOC init
140   004F              ; it assumes we have free space between the end of
141   004F              ; the compiled program and the stack pointer
142   004F              IF DEFINED_USING_amalloc
143   004F                  INCLUDE "crt/classic/crt_init_amalloc.asm"
144   004F              ENDIF
145   004F              
146   004F              IF CRT_ENABLE_COMMANDLINE = 1
147   004F  21 80 00        ld      hl,$80
148   0052  7E              ld      a,(hl)
149   0053                  ;ld      b,0
150   0053  44              ld      b,h
151   0054  A7              and     a
152   0055  CA D1 00        jp      z,argv_done
153   0058                  ;inc	hl
154   0058  4F              ld      c,a
155   0059  09              add     hl,bc   ;now points to the end of the command line
156   005A  0D              dec     c
157   005B                  INCLUDE	"crt/classic/crt_command_line.asm"
1     005B              ; Command line parsing
2     005B              
3     005B              ; Push pointers to argv[n] onto the stack now
4     005B              ; We must start from the end
5     005B              ; Entry:  hl = end of arguments
6     005B              ;	   c = length of arguments
7     005B              ;	   b = 0
8     005B              ; Exit:	  bc = argc
9     005B              ;         hl = argv
10    005B              
11    005B              IF CRT_ENABLE_COMMANDLINE = 1
12    005B  18 04           jr      argv_begin
13    005D              
14    005D  77 00       redir_fopen_flag:		defb	'w',0
15    005F  72          redir_fopen_flagr:		defb	'r'
16    0060  00          commandline_argv0:		defb	0
17    0061              
18    0061              argv_begin:
19    0061  11 00 00        ld      de,0	;NULL pointer at end of array, just in case
20    0064  D5              push    de
21    0065              ; Try to find the end of the arguments
22    0065              argv_loop_1:
23    0065  7E              ld      a,(hl)          ;Strip off trailing spaces
24    0066  FE 20           cp      ' '
25    0068  20 06           jr      nz,argv_loop_2
26    006A  36 00           ld      (hl),0
27    006C  2B              dec     hl
28    006D  0D              dec     c
29    006E  20 F5           jr      nz,argv_loop_1
30    0070              ; We've located the end of the last argument, try to find the start
31    0070              argv_loop_2:
32    0070  7E              ld      a,(hl)
33    0071  FE 20           cp      ' '
34    0073  20 58           jr      nz,argv_loop_3
35    0075  23              inc     hl              ; We're now on the first character of the argument
36    0076  0C              inc     c
37    0077              IF CRT_COMMANDLINE_REDIRECTION = 1
38    0077                      EXTERN freopen
39    0077  AF                  xor     a
40    0078  80                  add     b
41    0079  20 25               jr      nz,no_redir_stdout
42    007B  7E                  ld      a,(hl)
43    007C  FE 3E               cp      '>'
44    007E  20 20               jr      nz,no_redir_stdout
45    0080  E5                  push    hl
46    0081  23                  inc     hl
47    0082  BE                  cp      (hl)
48    0083  2B                  dec     hl
49    0084  11 5D 00            ld      de,redir_fopen_flag	; "a" or "w"
50    0087  20 04               jr      nz,noappendb
51    0089  3E 61               ld      a,'a'
52    008B  12                  ld      (de),a
53    008C  23                  inc     hl
54    008D              noappendb:
55    008D  23                  inc     hl
56    008E              
57    008E  C5                  push    bc
58    008F  E5                  push    hl					; file name ptr
59    0090  D5                  push    de
60    0091  11 0A 00            ld      de,__sgoioblk+10		; file struct for stdout
61    0094  D5                  push    de
62    0095  CD 00 00            call    freopen
63    0098  D1                  pop     de
64    0099  D1                  pop     de
65    009A  E1                  pop     hl
66    009B  C1                  pop     bc
67    009C  E1                  pop     hl
68    009D  2B                  dec     hl
69    009E  18 20               jr      argv_zloop
70    00A0              no_redir_stdout:
71    00A0  7E                  ld      a,(hl)
72    00A1  FE 3C               cp      '<'
73    00A3  20 17               jr      nz,no_redir_stdin
74    00A5  E5                  push    hl
75    00A6  23                  inc     hl
76    00A7  11 5F 00            ld      de,redir_fopen_flagr
77    00AA  C5                  push    bc
78    00AB  E5                  push    hl					; file name ptr
79    00AC  D5                  push    de
80    00AD  11 00 00            ld      de,__sgoioblk		; file struct for stdin
81    00B0  D5                  push    de
82    00B1  CD 00 00            call    freopen
83    00B4  D1                  pop     de
84    00B5  D1                  pop     de
85    00B6  E1                  pop     hl
86    00B7  C1                  pop     bc
87    00B8  E1                  pop     hl
88    00B9  2B                  dec	    hl
89    00BA  18 04               jr      argv_zloop
90    00BC              no_redir_stdin:
91    00BC              ENDIF
92    00BC  E5              push    hl
93    00BD  04              inc     b
94    00BE              empty_arg:
95    00BE  2B              dec     hl
96    00BF  0D              dec     c
97    00C0              ; skip extra blanks
98    00C0              argv_zloop:
99    00C0  36 00           ld      (hl),0      ;Terminate the previous argument
100   00C2  2B              dec     hl          ;Last character of previous argument
101   00C3  0D              dec     c
102   00C4  28 0B           jr      z,argv_done
103   00C6  7E              ld      a,(hl)
104   00C7  FE 20           cp      ' '
105   00C9  28 F5           jr      z,argv_zloop ;Skip over multiple spaces
106   00CB  18 A3           jr      argv_loop_2  ;And do the next argument
107   00CD              
108   00CD              argv_loop_3:
109   00CD  2B              dec     hl
110   00CE  0D              dec     c
111   00CF  20 9F           jr      nz,argv_loop_2
112   00D1              
113   00D1              argv_done:
114   00D1                  ; We may still have an argument left (if it was at the start of the buffer)
115   00D1              
116   00D1              argv_push_final_arg:
117   00D1  7E              ld      a,(hl)              ;Strip leading spaces
118   00D2  FE 20           cp      ' '
119   00D4  20 03           jr      nz,argv_push_final_arg2
120   00D6  23              inc     hl
121   00D7  18 F8           jr      argv_push_final_arg
122   00D9              argv_push_final_arg2:
123   00D9  D1              pop     de                  ;Is it the same as the last argument we pushed?
124   00DA  D5              push    de
125   00DB  7C              ld      a,h
126   00DC  92              sub     d
127   00DD  20 04           jr      nz,argv_push_final_arg3
128   00DF  7D              ld      a,l
129   00E0  93              sub     e
130   00E1  28 06           jr      z,argv_done_2
131   00E3              argv_push_final_arg3:
132   00E3  7E              ld      a,(hl)
133   00E4  A7              and     a
134   00E5  28 02           jr      z,argv_done_2
135   00E7  E5              push    hl
136   00E8  04              inc     b
137   00E9              
138   00E9              argv_done_2:
139   00E9  21 60 00        ld      hl,commandline_argv0	;name of program (NULL)
140   00EC  E5              push    hl
141   00ED  04              inc     b
142   00EE  21 00 00        ld      hl,0
143   00F1  39              add     hl,sp	;address of argv
144   00F2  48              ld      c,b
145   00F3  06 00           ld      b,0
146   00F5              ELSE
147   00F5                  ld      hl,0    ;argv
148   00F5                  ld      b,h     ;argc
149   00F5                  ld      c,l
150   00F5              ENDIF
151   00F5              
152   00F5              
153   00F5              
158   00F5  E5              push    hl	;argv
159   00F6  C5              push    bc	;argc
160   00F7              ELSE
161   00F7                  ld      hl,0
162   00F7                  push    hl  ;argv
163   00F7                  push    hl  ;argc
164   00F7              ENDIF
165   00F7  CD 00 00        call    _main		;Call user code
166   00FA  C1              pop     bc	;kill argv
167   00FB  C1              pop     bc	;kill argc
168   00FC              
169   00FC  3A 5B 02        ld      a,(defltdsk)	;Restore default disc
170   00FF  5F              ld      e,a
171   0100  0E 0E           ld      c,14
172   0102  CD 05 00        call    5
173   0105              
174   0105              cleanup:
175   0105  E5              push    hl		;Save return value
176   0106  CD 00 00        call    crt0_exit
177   0109  C1              pop     bc		;Get exit() value into bc
178   010A              start1:
179   010A  31 00 00        ld      sp,0		;Pick up entry sp
180   010D  C3 00 00        jp      0
181   0110              
182   0110  E9          l_dcal:	jp	(hl)		;Used for call by function ptr
183   0111              
184   0111              ; Memory banking for Spectrum +3
185   0111              IF (startup=3)
186   0111                  PUBLIC	pixelbyte
187   0111              pixelbyte:	defb	0		; temp byte storage for VDP driver
188   0111              
189   0111              p3_poke:
190   0111              		jp 0
191   0111              
192   0111              p3_peek:
193   0111              		jp 0
194   0111              
195   0111              pokebyte_code:
196   0111              		di
197   0111              		; ..$15 00010101 -> banks 4,5,6,3
198   0111              		; ..$11 00010001 -> banks 0,1,2,3 (TPA)
199   0111              		ex  af,af
200   0111              		ld	a,$15
201   0111              		;ld	a,$0D
202   0111              		;ld	a,$05
203   0111              		ld bc,$1ffd
204   0111              		out(c),a
205   0111              		ex af,af
206   0111              		ld (hl),a
207   0111              		ld	a,$11		; avoid using ($FF01) to be compatible with CP/M 2.2
208   0111              		;ld	a,$09
209   0111              		;ld	a,$01
210   0111              		;ld	a,($FF01)	; saved value
211   0111              		out(c),a
212   0111              		ei
213   0111              		ret
214   0111              		; adjust code size
215   0111              		nop
216   0111              peekbyte_code:
217   0111              		di
218   0111              		; ..$15 00010101 -> banks 4,5,6,3
219   0111              		; ..$11 00010001 -> banks 0,1,2,3 (TPA)
220   0111              		ld	a,$15
221   0111              		;ld	a,$0D
222   0111              		;ld	a,$05
223   0111              		ld bc,$1ffd
224   0111              		out(c),a
225   0111              		ld a,(hl)
226   0111              		ex  af,af
227   0111              		ld	a,$11		; avoid using ($FF01) to be compatible with CP/M 2.2
228   0111              		;ld	a,$09
229   0111              		;ld	a,$01
230   0111              		;ld	a,($FF01)	; saved value
231   0111              		out(c),a
232   0111              		ex  af,af
233   0111              		ei
234   0111              		ret
235   0111              		; adjust code size
236   0111              		nop
237   0111              ENDIF
238   0111              
239   0111              
240   0111                  INCLUDE "crt/classic/crt_runtime_selection.asm"
1     0111              ;
2     0111              ; Allow selection of the library functions at linktime
3     0111              ;
4     0111              ; Included by crt0 files
5     0111              ;
6     0111              
7     0111              
8     0111              ; scanf format picker
9     0111              
10    0111              ; Compatibility with the new library format picker. The classic library
11    0111              ; implements several of these together so there's an element of grouping.
12    0111              ;
13    0111              ; Default is to enable all converters except for float.
14    0111              ;
15    0111              ; Use -pragma-define:CLIB_OPT_SCANF=0x..... to control formatters
16    0111              ;
17    0111              ; bit 0 =  $    01 = enable %d
18    0111              ; bit 1 =  $    02 = enable %u
19    0111              ; bit 2 =  $    04 = enable %x
20    0111              ; bit 3 =  $    08 = enable %X (duplicate)
21    0111              ; bit 4 =  $    10 = enable %o
22    0111              ; bit 5 =  $    20 = enable %n
23    0111              ; bit 6 =  $    40 = enable %i
24    0111              ; bit 7 =  $    80 = enable %p
25    0111              ; bit 8 =  $   100 = enable %B
26    0111              ; bit 9 =  $   200 = enable %s
27    0111              ; bit 10 = $   400 = enable %c
28    0111              ; * bit 11 = $   800 = enable %I
29    0111              ; bit 12 = $  1000 = enable %ld
30    0111              ; bit 13 = $  2000 = enable %lu
31    0111              ; bit 14 = $  4000 = enable %lx
32    0111              ; bit 15 = $  8000 = enable %lX (duplicate)
33    0111              ; bit 16 = $ 10000 = enable %lo
34    0111              ; bit 17 = $ 20000 = enable %ln
35    0111              ; bit 18 = $ 40000 = enable %li
36    0111              ; bit 19 = $ 80000 = enable %lp
37    0111              ; bit 20 = $100000 = enable %lB
38    0111              ; * bit 21 = $200000 = enable %[
39    0111              ; * bit 22 = $  400000 = enable %a
40    0111              ; * bit 23 = $  800000 = enable %A
41    0111              ; bit 24 = $ 1000000 = enable %e
42    0111              ; bit 25 = $ 2000000 = enable %E
43    0111              ; bit 26 = $ 4000000 = enable %f
44    0111              ; bit 27 = $ 8000000 = enable %F
45    0111              ; bit 28 = $10000000 = enable %g
46    0111              ; bit 29 = $20000000 = enable %G
47    0111              ; bit 30 = $40000000 = enable flags handling
48    0111              
49    0111              IF DEFINED_CLIB_OPT_SCANF
50    0111              	; User has specified the configuration level - force scanf to be included
51    0111              	UNDEFINE NEED_scanf
52    0111              	DEFINE NEED_scanf
53    0111              ELSE
54    0111              	IF DEFINED_CRT_scanf_format
55    0111              	    ;Only defined as part of sccz80
56    0111              	    defc CLIB_OPT_SCANF = CRT_scanf_format
57    0111                      ELSE
58    0111              	    ; TODO: Some default configurations
59    0111                      ENDIF
60    0111              ENDIF
61    0111              
62    0111              
63    0111              IF NEED_scanf
64    0111              	PUBLIC	__scanf_format_table
65    0111              	EXTERN	__scanf_handle_d
66    0111              	EXTERN	__scanf_handle_u
67    0111              	EXTERN	__scanf_handle_o
68    0111              	EXTERN	__scanf_handle_x
69    0111              	EXTERN	__scanf_handle_p
70    0111              	EXTERN	__scanf_handle_B
71    0111              	EXTERN	__scanf_handle_f
72    0111              	EXTERN	__scanf_handle_s
73    0111              	EXTERN	__scanf_handle_c
74    0111              	EXTERN	__scanf_handle_n
75    0111              	EXTERN	__scanf_handle_i
76    0111              	EXTERN	__scanf_noop
77    0111              
78    0111              __scanf_format_table:
79    0111              IF CLIB_OPT_SCANF & $40040
80    0111              	defb	'i'
81    0111              	defw	__scanf_handle_i
82    0111              	defc	temp_CLIB_OPT_SCANF = CLIB_OPT_SCANF
83    0111              	UNDEFINE CLIB_OPT_SCANF
84    0111              	defc	CLIB_OPT_SCANF = temp_CLIB_OPT_SCANF | 0x3003 | 0x8c08c | 0x10010 | 0x100100
85    0111              ENDIF
86    0111              
87    0111              
88    0111              
89    0111              IF CLIB_OPT_SCANF & $2002
90    0111              	defb	'u'
91    0111              	defw	__scanf_handle_u
92    0111              ENDIF
93    0111              
94    0111              IF CLIB_OPT_SCANF & $1001
95    0111              	defb	'd'
96    0111              	defw	__scanf_handle_d
97    0111              ENDIF
98    0111              
99    0111              IF CLIB_OPT_SCANF & $c00c
100   0111              	defb	'x'
101   0111              	defw	__scanf_handle_x
102   0111              ENDIF
103   0111              
104   0111              IF CLIB_OPT_SCANF & $80080
105   0111              	defb	'p'
106   0111              	defw	__scanf_handle_x
107   0111              ENDIF
108   0111              
109   0111              IF CLIB_OPT_SCANF & $10010
110   0111              	defb	'o'
111   0111              	defw	__scanf_handle_o
112   0111              ENDIF
113   0111              
114   0111              IF CLIB_OPT_SCANF & $100100
115   0111              	defb	'B'
116   0111              	defw	__scanf_handle_B
117   0111              ENDIF
118   0111              
119   0111              IF CLIB_OPT_SCANF & $20020
120   0111              	defb	'n'
121   0111              	defw	__scanf_handle_n
122   0111              ENDIF
123   0111              
124   0111              IF CLIB_OPT_SCANF & $200
125   0111              	defb	's'
126   0111              	defw	__scanf_handle_s
127   0111              ENDIF
128   0111              
129   0111              IF CLIB_OPT_SCANF & $400
130   0111              	defb	'c'
131   0111              	defw	__scanf_handle_c
132   0111              ENDIF
133   0111              
134   0111              IF CLIB_OPT_SCANF & $4000000
135   0111              	defb	'f'
136   0111              	defw	__scanf_handle_f
137   0111              ENDIF
138   0111              
139   0111              IF CLIB_OPT_SCANF & $1000000
140   0111              	defb	'e'
141   0111              	defw	__scanf_handle_f
142   0111              ENDIF
143   0111              IF CLIB_OPT_SCANF & $10000000
144   0111              	defb	'g'
145   0111              	defw	__scanf_handle_f
146   0111              ENDIF
147   0111              
148   0111              	defb	0	;end marker
149   0111              ENDIF
150   0111              
151   0111              ;
152   0111              ; printf format picker
153   0111              ;
154   0111              
155   0111              
156   0111              IF DEFINED_CLIB_OPT_PRINTF
157   0111              	; User has specified the configuration level - force printf to be included
158   0111              	UNDEFINE NEED_printf
159   0111              	DEFINE NEED_printf
160   0111              ELSE
161   0111              	IF DEFINED_CRT_printf_format
162   0111              	    ;Only defined as part of sccz80
163   0111              	    defc CLIB_OPT_PRINTF = CRT_printf_format
164   0111                      ELSE
165   0111              	    ; Default configurations to match old behaviour
166   0111              	    ; The built in one is roughly the old ministdio
167   0111              	    IF DEFINED_complexstdio
168   0111                              defc CLIB_OPT_PRINTF = 0x851BF7BF
169   0111                          ELSE
170   0111              	        defc CLIB_OPT_PRINTF = 0x801BF7BF
171   0111                          ENDIF
172   0111                      ENDIF
173   0111              ENDIF
174   0111              
175   0111              IF DEFINED_CLIB_OPT_PRINTF_2
176   0111              	; User has specified the configuration level - force printf to be included
177   0111              	UNDEFINE NEED_printf
178   0111              	DEFINE NEED_printf
179   0111              ENDIF
180   0111              
181   0111              IF NEED_printf
182   0111              	PUBLIC	__printf_format_table
183   0111              	PUBLIC  __printf_format_table64
184   0111              	EXTERN	__printf_handle_d
185   0111              	EXTERN	__printf_handle_u
186   0111              	EXTERN	__printf_handle_o
187   0111              	EXTERN	__printf_handle_x
188   0111              	EXTERN	__printf_handle_X
189   0111              	EXTERN	__printf_handle_p
190   0111              	EXTERN	__printf_handle_e
191   0111              	EXTERN	__printf_handle_f
192   0111              	EXTERN	__printf_handle_s
193   0111              	EXTERN	__printf_handle_c
194   0111              	EXTERN	__printf_handle_n
195   0111              	EXTERN	__printf_handle_B
196   0111              	EXTERN	__printf_handle_ll
197   0111              	EXTERN	__printf_handle_lld
198   0111              	EXTERN	__printf_handle_llu
199   0111              	EXTERN	__printf_handle_llo
200   0111              	EXTERN	__printf_handle_llx
201   0111              	EXTERN	__printf_handle_llX
202   0111              	EXTERN	__printf_handle_llB
203   0111              
204   0111              __printf_format_table:
205   0111              
206   0111              IF CLIB_OPT_PRINTF & $2002
207   0111              	defb	'u'
208   0111              	defw	__printf_handle_u
209   0111              ENDIF
210   0111              
211   0111              IF CLIB_OPT_PRINTF & $1001
212   0111              	defb	'd'
213   0111              	defw	__printf_handle_d
214   0111              ENDIF
215   0111              
216   0111              IF CLIB_OPT_PRINTF & $4004
217   0111              	defb	'x'
218   0111              	defw	__printf_handle_x
219   0111              ENDIF
220   0111              
221   0111              IF CLIB_OPT_PRINTF & $8008
222   0111              	defb	'X'
223   0111              	defw	__printf_handle_X
224   0111              ENDIF
225   0111              
226   0111              IF CLIB_OPT_PRINTF & $80080
227   0111              	defb	'p'
228   0111              	defw	__printf_handle_x
229   0111              ENDIF
230   0111              
231   0111              IF CLIB_OPT_PRINTF & $100100
232   0111              	defb	'B'
233   0111              	defw	__printf_handle_B
234   0111              ENDIF
235   0111              
236   0111              IF CLIB_OPT_PRINTF  & $10010
237   0111              	defb	'o'
238   0111              	defw	__printf_handle_o
239   0111              ENDIF
240   0111              
241   0111              IF CLIB_OPT_PRINTF & $20020
242   0111              	defb	'n'
243   0111              	defw	__printf_handle_n
244   0111              ENDIF
245   0111              
246   0111              IF CLIB_OPT_PRINTF & $200
247   0111              	defb	's'
248   0111              	defw	__printf_handle_s
249   0111              ENDIF
250   0111              
251   0111              IF CLIB_OPT_PRINTF & $400
252   0111              	defb	'c'
253   0111              	defw	__printf_handle_c
254   0111              ENDIF
255   0111              
256   0111              IF CLIB_OPT_PRINTF & $4000000
257   0111              	defb	'f'
258   0111              	defw	__printf_handle_f
259   0111              ENDIF
260   0111              
261   0111              IF CLIB_OPT_PRINTF  & $1000000
262   0111              	defb	'e'
263   0111              	defw	__printf_handle_e
264   0111              ENDIF
265   0111              IF CLIB_OPT_PRINTF & $10000000
266   0111              	defb	'g'
267   0111              	defw	__printf_handle_f
268   0111              ENDIF
269   0111              IF CLIB_OPT_PRINTF_2
270   0111              	defb	'l'
271   0111              	defw	__printf_handle_ll
272   0111              ENDIF
273   0111              	defb	0	;end marker
274   0111              
275   0111              __printf_format_table64:
276   0111              
277   0111              IF CLIB_OPT_PRINTF_2 & $02
278   0111              	defb	'u'
279   0111              	defw	__printf_handle_llu
280   0111              ENDIF
281   0111              
282   0111              IF CLIB_OPT_PRINTF_2 & $01
283   0111              	defb	'd'
284   0111              	defw	__printf_handle_lld
285   0111              ENDIF
286   0111              
287   0111              IF CLIB_OPT_PRINTF_2 & $04
288   0111              	defb	'x'
289   0111              	defw	__printf_handle_llx
290   0111              ENDIF
291   0111              
292   0111              IF CLIB_OPT_PRINTF_2 & $08
293   0111              	defb	'X'
294   0111              	defw	__printf_handle_llX
295   0111              ENDIF
296   0111              IF CLIB_OPT_PRINTF_2  & $10
297   0111              	defb	'o'
298   0111              	defw	__printf_handle_llo
299   0111              ENDIF
300   0111              IF CLIB_OPT_PRINTF_2 & $100
301   0111              	defb	'B'
302   0111              	defw	__printf_handle_llB
303   0111              ENDIF
304   0111              	defb	0	;endmarker
305   0111              
306   0111              
307   0111              
308   0111              IF CLIB_OPT_PRINTF & $40000000
309   0111              	EXTERN	__printf_get_flags_impl
310   0111              	PUBLIC	__printf_get_flags
311   0111              	defc	__printf_get_flags = __printf_get_flags_impl
312   0111              ELSE
313   0111              	EXTERN	__printf_get_flags_noop
314   0111              	PUBLIC	__printf_get_flags
315   0111              	defc	__printf_get_flags = __printf_get_flags_noop
316   0111              ENDIF
317   0111              
318   0111              ENDIF
319   0111              
320   0111              
321   0111              ;--------
322   0111              ; Allow a compile time switch between native output and ANSI terminal
323   0111              ;
324   0111              ; -pragma-need=ansiterminal
325   0111              ;--------
326   0111              
327   0111              IF NEED_ansiterminal
328   0111              	PUBLIC		fputc_cons
329   0111              	EXTERN		fputc_cons_ansi
330   0111              	EXTERN		puts_cons_ansi
331   0111              	defc DEFINED_fputc_cons = 1
332   0111              	defc DEFINED_puts_cons = 1
333   0111              	defc fputc_cons = fputc_cons_ansi
334   0111              
335   0111              	; Bridge VT100 to gencon
336   0111                      IF DEFINED_CLIB_ANSITERMINAL_BRIDGE & CLIB_ANSITERMINAL_BRIDGE != 0
337   0111                          PUBLIC ansi_attr
338   0111                          PUBLIC ansi_BEL
339   0111                          PUBLIC ansi_cls
340   0111                          PUBLIC ansi_CHAR
341   0111                          PUBLIC ansi_del_line
342   0111                          PUBLIC ansi_SCROLLUP
343   0111                          EXTERN __gencon_ansi_attr
344   0111                          EXTERN __gencon_ansi_BEL
345   0111                          EXTERN __gencon_ansi_cls
346   0111                          EXTERN __gencon_ansi_CHAR
347   0111                          EXTERN __gencon_ansi_del_line
348   0111                          EXTERN __gencon_ansi_SCROLLUP
349   0111                          defc ansi_attr = __gencon_ansi_attr
350   0111                          defc ansi_BEL = __gencon_ansi_BEL
351   0111                          defc ansi_cls = __gencon_ansi_cls
352   0111                          defc ansi_CHAR = __gencon_ansi_CHAR
353   0111                          defc ansi_del_line = __gencon_ansi_del_line
354   0111                          defc ansi_SCROLLUP = __gencon_ansi_SCROLLUP
355   0111              
356   0111                          ; We're using gencon, don't include an ANSIfont
357   0111                          UNDEFINE TAR__no_ansifont
358   0111                          defc TAR__no_ansifont = 1
359   0111              	    IF !DEFINED_ansicolumns
360   0111                              defc ansicolumns = CONSOLE_COLUMNS
361   0111                              defc DEFINED_ansicolumns = 1
362   0111                          ENDIF
363   0111                      ENDIF
364   0111              
365   0111                     	PUBLIC ansicolumns
366   0111              
367   0111              	IF !TAR__no_ansifont
368   0111                      	PUBLIC ansicharacter_pixelwidth
369   0111              		PUBLIC ansifont
370   0111                      	PUBLIC ansifont_is_packed
371   0111                      ELSE
372   0111                              defc DEFINED_ansifont = 1
373   0111              	ENDIF
374   0111              
375   0111              	IF !ansipixels
376   0111              		defc ansipixels = 256
377   0111              	ENDIF
378   0111              
379   0111              	IF !DEFINED_ansicolumns
380   0111              		 defc ansicolumns = 64
381   0111              	ENDIF
382   0111              
383   0111              	UNDEFINE CONSOLE_COLUMNS
384   0111              	defc CONSOLE_COLUMNS = ansicolumns
385   0111              
386   0111              	IF DEFINED_ansirows
387   0111              		UNDEFINE CONSOLE_ROWS
388   0111              		defc CONSOLE_ROWS = ansirows
389   0111              	ENDIF
390   0111              
391   0111              
392   0111              	IF (ansicolumns = (ansipixels/2))
393   0111              	    defc ansicharacter_pixelwidth = 2
394   0111                          IF !DEFINED_ansifont
395   0111                          	EXTERN ansifont_f4pack
396   0111              	    	defc ansifont = ansifont_f4pack
397   0111                          	defc ansifont_is_packed = 1
398   0111                          ENDIF
399   0111              	ENDIF
400   0111              	IF (ansicolumns = (ansipixels/3))
401   0111              	    defc ansicharacter_pixelwidth = 3
402   0111                          IF !DEFINED_ansifont
403   0111                              EXTERN ansifont_f4pack
404   0111              	        defc ansifont = ansifont_f4pack
405   0111                              defc ansifont_is_packed = 1
406   0111              	    ENDIF
407   0111              	ENDIF
408   0111              	IF (ansicolumns = (ansipixels/4))
409   0111              	    defc ansicharacter_pixelwidth = 4
410   0111                          IF !DEFINED_ansifont
411   0111                              EXTERN ansifont_f4pack
412   0111              	        defc ansifont = ansifont_f4pack
413   0111                              defc ansifont_is_packed = 1
414   0111              	    ENDIF
415   0111              	ENDIF
416   0111              	IF (ansicolumns = (ansipixels/5))
417   0111              	    defc ansicharacter_pixelwidth = 5
418   0111                          IF !DEFINED_ansifont
419   0111                              EXTERN ansifont_f5
420   0111              	        defc ansifont = ansifont_f5
421   0111                              defc ansifont_is_packed = 0
422   0111              	    ENDIF
423   0111              	ENDIF
424   0111              	IF (ansicolumns = (ansipixels/6))
425   0111              	    defc ansicharacter_pixelwidth = 6
426   0111                          IF !DEFINED_ansifont
427   0111                              EXTERN ansifont_f6
428   0111              	        defc ansifont = ansifont_f6
429   0111                              defc ansifont_is_packed = 0
430   0111              	    ENDIF
431   0111              	ENDIF
432   0111              	IF (ansicolumns = (ansipixels/7))
433   0111              	    defc ansicharacter_pixelwidth = 7
434   0111                          IF !DEFINED_ansifont
435   0111                              EXTERN ansifont_f8
436   0111              	        defc ansifont = ansifont_f8
437   0111                              defc ansifont_is_packed = 0
438   0111              	    ENDIF
439   0111              	ENDIF
440   0111              	IF (ansicolumns = (ansipixels/8))
441   0111              	    defc ansicharacter_pixelwidth = 8
442   0111                          IF !DEFINED_ansifont
443   0111                              EXTERN ansifont_f8
444   0111              	        defc ansifont = ansifont_f8
445   0111                              defc ansifont_is_packed = 0
446   0111              	    ENDIF
447   0111              	ENDIF
448   0111              	IF (ansicolumns = (ansipixels/9))
449   0111              	    defc ansicharacter_pixelwidth = 9
450   0111                          IF !DEFINED_ansifont
451   0111                              EXTERN ansifont_f8
452   0111              	        defc ansifont = ansifont_f8
453   0111                              defc ansifont_is_packed = 0
454   0111              	    ENDIF
455   0111              	ENDIF
456   0111              
457   0111              	IF (ansipixels = 512)
458   0111              		IF (ansicolumns = 48)
459   0111              			defc ansicharacter_pixelwidth = 9
460   0111              			IF !DEFINED_ansifont
461   0111              				EXTERN ansifont_f8
462   0111              				defc ansifont = ansifont_f8
463   0111              				defc ansifont_is_packed = 0
464   0111              			ENDIF
465   0111              		ENDIF
466   0111              		IF (ansicolumns = 80)
467   0111              			defc ansicharacter_pixelwidth = 6
468   0111              			IF !DEFINED_ansifont
469   0111              				EXTERN ansifont_f6
470   0111              				defc ansifont = ansifont_f6
471   0111              				defc ansifont_is_packed = 0
472   0111              			ENDIF
473   0111              		ENDIF
474   0111              		IF (ansicolumns = 160)
475   0111              			defc ansicharacter_pixelwidth = 3
476   0111              			IF !DEFINED_ansifont
477   0111              				EXTERN ansifont_f4pack
478   0111              				defc ansifont = ansifont_f4pack
479   0111              				defc ansifont_is_packed = 1
480   0111              			ENDIF
481   0111              		ENDIF
482   0111              	ENDIF
483   0111              
484   0111              	IF (ansipixels = 256)
485   0111              		IF (ansicolumns = 24)
486   0111              			defc ansicharacter_pixelwidth = 9
487   0111              			IF !DEFINED_ansifont
488   0111              				EXTERN ansifont_f8
489   0111              				defc ansifont = ansifont_f8
490   0111              				defc ansifont_is_packed = 0
491   0111              			ENDIF
492   0111              		ENDIF
493   0111              		IF (ansicolumns = 40)
494   0111              			defc ansicharacter_pixelwidth = 6
495   0111              			IF !DEFINED_ansifont
496   0111              				EXTERN ansifont_f6
497   0111              				defc ansifont = ansifont_f6
498   0111              				defc ansifont_is_packed = 0
499   0111              			ENDIF
500   0111              		ENDIF
501   0111              		IF (ansicolumns = 80)
502   0111              			defc ansicharacter_pixelwidth = 3
503   0111              			IF !DEFINED_ansifont
504   0111              				EXTERN ansifont_f4pack
505   0111              				defc ansifont = ansifont_f4pack
506   0111              				defc ansifont_is_packed = 1
507   0111              			ENDIF
508   0111              		ENDIF
509   0111              	ENDIF
510   0111              
511   0111              ENDIF
512   0111              
513   0111              ; If it's not been overridden by anybody, lets use the native output
514   0111              IF !DEFINED_fputc_cons
515   0111              	PUBLIC		fputc_cons
516   0111              	defc DEFINED_fputc_cons = 1
517   0111                      IF !TAR__fputc_cons_generic
518   0111              	     EXTERN	fputc_cons_native
519   0111                	     defc fputc_cons = fputc_cons_native
520   0111                      ELSE
521   0111              	     EXTERN	fputc_cons_generic
522   0111                	     defc fputc_cons = fputc_cons_generic
523   0111                      ENDIF
524   0111              ENDIF
525   0111              
526   0111              IF DEFINED_fputc_cons
527   0111              	PUBLIC		_fputc_cons
528   0111              	defc		_fputc_cons = fputc_cons
529   0111              
530   0111              ENDIF
531   0111              
532   0111              IF !DEFINED_getk
533   0111                 IF !DEFINED_fgetc_cons
534   0111                    IF TAR__fgetc_cons_inkey
535   0111                        EXTERN fgetc_cons_inkey
536   0111                        EXTERN getk_inkey
537   0111                        PUBLIC fgetc_cons
538   0111                        PUBLIC _fgetc_cons
539   0111                        PUBLIC getk
540   0111                        PUBLIC _getk
541   0111                        defc fgetc_cons = fgetc_cons_inkey
542   0111                        defc _fgetc_cons = fgetc_cons_inkey
543   0111                        defc getk = getk_inkey
544   0111                        defc _getk = getk_inkey
545   0111                    ENDIF
546   0111                 ENDIF
547   0111              ENDIF
548   0111              
549   0111              IF DEFINED_fgetc_cons
550   0111                IF !DEFINED__fgetc_cons
551   0111                    PUBLIC _fgetc_cons
552   0111                    defc _fgetc_cons = fgetc_cons
553   0111                ENDIF
554   0111              ENDIF
555   0111              
556   0111              IF DEFINED_getk
557   0111                IF !DEFINED__getk
558   0111                    PUBLIC _getk
559   0111                    defc _getk = getk
560   0111                ENDIF
561   0111              ENDIF
562   0111              
563   0111              
564   0111              ;TODO: These need to go into rules
565   0111              IF CONSOLE_COLUMNS
566   0111              	PUBLIC CONSOLE_COLUMNS
567   0111              ENDIF
568   0111              IF CONSOLE_ROWS
569   0111              	PUBLIC CONSOLE_ROWS
570   0111              ENDIF
571   0111              
572   0111              IF !CONSOLE_XOFFSET
573   0111                  defc CONSOLE_XOFFSET = 0
574   0111              ENDIF
575   0111              PUBLIC CONSOLE_XOFFSET
576   0111              IF !CONSOLE_YOFFSET
577   0111                  defc CONSOLE_YOFFSET = 0
578   0111              ENDIF
579   0111              PUBLIC CONSOLE_YOFFSET
580   0111              
581   0111              IF !CLIB_KBHIT_NOSTORE
582   0111                  defc CLIB_KBHIT_NOSTORE = 0
583   0111              ENDIF
584   0111              PUBLIC CLIB_KBHIT_NOSTORE
585   0111              
586   0111              
587   0111              
241   0111                  INCLUDE	"crt/classic/crt_section.asm"
1     0111              ; Memory map and section setup
2     0111              ;
3     0111              ; Contains the generic variables + features
4     0111              
5     0111              ;
6     0111              ; crt_model = 0		; everything in RAM
7     0111              ; crt_model = 1		; ROM model, data section copied
8     0111              ; crt_model = 2		; ROM model, data section compressed with zx7
9     0111              ; crt_model = 3		; ROM model, data section compressed with zx0
10    0111              
11    0111              ; Include the default memory map. You can override this
12    0111              
13    0111              IF __MMAP == -1
14    0111                  ; The user has supplied a memory map.
15    0111                  INCLUDE	"./mmap.inc"
16    0111              ELSE
17    0111                  ; Include the standard memory map
18    0111                  INCLUDE	"crt/classic/crt_section_standard.asm"
1     0111              ; Classic Memory map and section setup
2     0111              ;
3     0111              ; This layout suits all the classic machines. Memory placement is
4     0111              ; affected by:
5     0111              ;
6     0111              ; CRT_MODEL: RAM/ROM configuration
7     0111              ; CRT_ORG_CODE: Where code starts executing from
8     0111              ; CRT_ORG_BSS:  Where uninitialised global variables are placed
9     0111              ; CRT_ORG_GRAPHICS: Where graphics routines + variables are stored (certain ports only)
10    0111              
11    0111              ;
12    0111              ; Contains the generic variables + features
13    0111              
14    0111              ;
15    0111              ; crt_model = 0		; everything in RAM
16    0111              ; crt_model = 1		; ROM model, data section copied
17    0111              ; crt_model = 2		; ROM model, data section compressed (zx7)
18    0111              ; crt_model = 3		; ROM model, data section compressed (zx0)
19    0111              
20    0111              
21    0111              
22    0111                  INCLUDE "crt/classic/crt_section_code.inc"
1     0111              ; CODE sections defined by the classic library
2     0111              
3     0111                  SECTION CODE
4     0000                  SECTION code_crt_init
5     0000                  SECTION code_crt_init_exit
6     0000                  SECTION code_crt_exit
7     0000                  SECTION code_crt_exit_exit
8     0000                  SECTION code_driver
9     0000                  SECTION rodata_driver       ;Keep it in low memoey
10    0000                  SECTION code_compiler
11    0000                  SECTION code_clib
12    0000                  SECTION code_l
13    0000                  SECTION code_l_sdcc
14    0000                  SECTION code_l_sccz80
15    0000                  SECTION code_compress_zx7
16    0000                  SECTION code_compress_zx0
17    0000                  SECTION code_compress_zx1
18    0000                  SECTION code_compress_zx2
19    0000                  SECTION code_compress_aplib
20    0000                  SECTION code_ctype
21    0000                  SECTION code_esxdos
22    0000                  SECTION code_fp
23    0000                  SECTION code_fp_math48
24    0000                  SECTION code_fp_math32
25    0000                  SECTION code_fp_math16
26    0000                  SECTION code_fp_mbf32
27    0000                  SECTION code_fp_mbf64
28    0000                  SECTION code_fp_am9511
29    0000                  SECTION code_fp_dai32
30    0000                  SECTION code_math
31    0000                  SECTION code_error
32    0000                  SECTION code_stdlib
33    0000                  SECTION code_string
34    0000                  SECTION code_adt_b_array
35    0000                  SECTION code_adt_b_vector
36    0000                  SECTION code_adt_ba_priority_queue
37    0000                  SECTION code_adt_ba_stack
38    0000                  SECTION code_adt_bv_priority_queue
39    0000                  SECTION code_adt_bv_stack
40    0000                  SECTION code_adt_p_forward_list
41    0000                  SECTION code_adt_p_forward_list_alt
42    0000                  SECTION code_adt_p_list
43    0000                  SECTION code_adt_p_queue
44    0000                  SECTION code_adt_p_stack
45    0000                  SECTION code_adt_w_array
46    0000                  SECTION code_adt_w_vector
47    0000                  SECTION code_adt_wa_priority_queue
48    0000                  SECTION code_adt_wa_stack
49    0000                  SECTION code_adt_wv_priority_queue
50    0000                  SECTION code_adt_wv_stack
51    0000                  SECTION code_alloc_balloc
52    0000                  SECTION code_alloc_obstack
53    0000                  SECTION code_arch
54    0000                  SECTION code_font
55    0000                  SECTION code_font_fzx
56    0000                  SECTION code_psg
57    0000                  SECTION code_sound_ay
58    0000                  SECTION code_PSGlib
59    0000                  SECTION code_time
60    0000                  SECTION code_z80
61    0000                  SECTION code_sprite_sp1
62    0000                  SECTION code_temp_sp1
63    0000                  SECTION code_splib2
64    0000              IF !__crt_org_graphics
65    0000                  SECTION code_graphics
66    0000              ENDIF
67    0000                  SECTION code_user
68    0000                  SECTION CODE_END
69    0000              
23    0000                  INCLUDE "crt/classic/crt_section_rodata.inc"
1     0000              ; RODATA sections defined by the classic library
2     0000              
3     0000                  SECTION RODATA
4     0000                  SECTION rodata_fp
5     0000                  SECTION rodata_fp_math48
6     0000                  SECTION rodata_fp_math32
7     0000                  SECTION rodata_fp_math16
8     0000                  SECTION rodata_fp_mbf32
9     0000                  SECTION rodata_fp_mbf64
10    0000                  SECTION rodata_fp_am9511
11    0000                  SECTION rodata_fp_dai32
12    0000                  SECTION rodata_arch
13    0000                  SECTION rodata_compiler
14    0000                  SECTION rodata_clib
15    0000                  SECTION rodata_psg
16    0000                  SECTION rodata_sound_ay
17    0000              IF !__crt_org_graphics
18    0000                  SECTION rodata_graphics
19    0000              ENDIF
20    0000                  SECTION rodata_user
21    0000                  SECTION rodata_font
22    0000                  SECTION rodata_font_fzx
23    0000                  SECTION rodata_font_4x8
24    0000                  SECTION rodata_font_6x8
25    0000                  SECTION rodata_font_8x8
26    0000                  SECTION rodata_font_8x10
27    0000                  SECTION rodata_font_ansi
28    0000                  SECTION rodata_splib2
29    0000                  ; Keep the following section last of all
30    0000                  SECTION rodata_appdor
31    0000                  SECTION RODATA_END
32    0000              
24    0000                  SECTION ROMABLE_END
25    0000              IF !__crt_model
26    0000                  INCLUDE "crt/classic/crt_section_data.inc"
1     0000              
2     0000              
3     0000                  SECTION DATA
4     0000                IF !__crt_org_graphics
5     0000                  SECTION smc_clib
6     0000                ENDIF
7     0000                  SECTION smc_fp
8     0000                  SECTION smc_compress
9     0000                  SECTION smc_user
10    0000                  SECTION data_driver
11    0000                  SECTION data_clib
12    0000                  SECTION data_stdlib
13    0000                  SECTION data_psg
14    0000                  SECTION data_sound_ay
15    0000                  SECTION	data_PSGlib
16    0000                IF !__crt_org_graphics
17    0000                  SECTION data_graphics
18    0000                ENDIF
19    0000                  SECTION data_crt
20    0000                  SECTION data_fp_mbf32
21    0000                  SECTION data_arch
22    0000                  SECTION data_compiler
23    0000                  SECTION data_splib2
24    0000                  SECTION data_user
25    0000                  SECTION data_alloc_balloc
26    0000                  SECTION DATA_END
27    0000              
27    0000              ENDIF
28    0000                  INCLUDE "crt/classic/crt_section_bss.inc"
1     0000                  SECTION BSS
2     0000              IF __crt_org_bss
3     0000                  org     __crt_org_bss
4     0000                  defb    0   ; control name of bss binary
5     0000              ENDIF
6     0000                  SECTION bss_fp
7     0000                  SECTION bss_fp_math32
8     0000                  SECTION bss_fp_math16
9     0000                  SECTION bss_fp_mbf32
10    0000                  SECTION bss_fp_mbf64
11    0000                  SECTION bss_fp_am9511
12    0000                  SECTION bss_fp_dai32
13    0000                  SECTION bss_compress_aplib
14    0000                  SECTION bss_error
15    0000                  SECTION bss_crt
16    0000                  SECTION bss_fardata
17    0000              IF __crt_org_bss_fardata_start
18    0000                  org	__crt_org_bss_fardata_start
19    0000              ENDIF
20    0000                  SECTION bss_compiler
21    0000              IF __crt_org_bss_compiler_start
22    0000                  org	__crt_org_bss_compiler_start
23    0000              ENDIF
24    0000                  SECTION bss_driver
25    0000                  SECTION bss_arch
26    0000                  SECTION bss_clib
27    0000                  SECTION bss_string
28    0000                  SECTION bss_alloc_balloc
29    0000              IF !__crt_org_graphics
30    0000                  SECTION bss_graphics
31    0000              ENDIF
32    0000                  SECTION bss_psg
33    0000                  SECTION bss_sound_ay
34    0000                  SECTION	bss_PSGlib
35    0000                  SECTION bss_splib2
36    0000                  SECTION bss_user
37    0000              
29    0000              
30    0000              IF __crt_model > 0
31    0000                  SECTION DATA
32    0000                  org     -1
33    0000                  defb    0		; control name of data binary
34    0000                  INCLUDE "crt/classic/crt_section_data.inc"
35    0000              ENDIF
36    0000                  SECTION BSS_END
37    0000              
38    0000              IF __crt_org_graphics
39    0000                  SECTION	HIMEM
40    0000                  org	__crt_org_graphics
41    0000                  SECTION smc_clib
42    0000                  SECTION code_graphics
43    0000                  SECTION code_himem
44    0000                  SECTION rodata_graphics
45    0000                  SECTION rodata_himem
46    0000                  SECTION data_himem
47    0000                  SECTION data_graphics
48    0000                  SECTION bss_graphics
49    0000                  SECTION bss_himem
50    0000                  SECTION HIMEM_END
51    0000              ENDIF
52    0000              
19    0000              ENDIF
20    0000              
21    0000              
22    0000              ; The classic CRTs need some things setup, so do it
23    0000              
24    0000                  SECTION code_crt_init
25    0000              crt0_init_bss:
26    0000                  EXTERN  __BSS_head
27    0000                  EXTERN  __BSS_END_tail
28    0000              IF CRT_INITIALIZE_BSS = 1
29    0000  21 00 00        ld      hl,__BSS_head
30    0003  01 FF FF        ld      bc,__BSS_END_tail - __BSS_head - 1
31    0006                IF !__CPU_INTEL__ && !__CPU_GBZ80__
32    0006  11 01 00        ld      de,__BSS_head + 1
33    0009  AF              xor     a
34    000A  77              ld	(hl),a
35    000B  ED B0           ldir
36    000D                ELSE
37    000D              init_8080_1:
38    000D                  ld	(hl),0
39    000D                  inc	hl
40    000D                  dec	bc
41    000D                  ld	a,b
42    000D                  or	c
43    000D                  jp	nz,init_8080_1
44    000D                ENDIF
45    000D              ELSE
46    000D                  xor     a
47    000D              ENDIF
48    000D              
49    000D                  ; a = 0 - reset exitcount
50    000D  32 68 00        ld      (exitcount),a
51    0010              IF CRT_ENABLE_STDIO = 1
52    0010              	; Setup std* streams
53    0010  21 02 00        ld      hl,__sgoioblk+2
54    0013  36 13           ld      (hl),19 ;stdin
55    0015  21 0C 00        ld      hl,__sgoioblk+12
56    0018  36 15           ld      (hl),21 ;stdout
57    001A  21 16 00        ld      hl,__sgoioblk+22
58    001D  36 15           ld      (hl),21 ;stderr
59    001F              ENDIF
60    001F              IF DEFINED_USING_amalloc
61    001F                IF __CPU_GBZ80__
62    001F                  ld      hl,__BSS_END_tail
63    001F                  ld      a,l
64    001F                  ld      (_heap),a
65    001F                  ld      a,h
66    001F                  ld      (_heap+1),a
67    001F                ELSE
68    001F                  ld      hl,__BSS_END_tail
69    001F                  ld      (_heap),hl
70    001F                ENDIF
71    001F              ENDIF
72    001F              IF ( __crt_model = 1 )
73    001F                  ; Just copy the DATA section
74    001F                  EXTERN	__ROMABLE_END_tail
75    001F                  EXTERN	__DATA_head
76    001F                  EXTERN	__DATA_END_tail
77    001F                  ld	hl,__ROMABLE_END_tail
78    001F                  ld	de,__DATA_head
79    001F                  ld	bc,__DATA_END_tail - __DATA_head
80    001F                  EXTERN  asm_memcpy
81    001F                  call    asm_memcpy
82    001F              ELIF ( __crt_model >= 2 )
83    001F                  EXTERN	__ROMABLE_END_tail
84    001F                  EXTERN	__DATA_head
85    001F                  ld      hl,__ROMABLE_END_tail
86    001F                  ld      de,__DATA_head
87    001F                IF ( __crt_model = 2)
88    001F                  EXTERN  asm_dzx7_standard
89    001F                  call    asm_dzx7_standard
90    001F                ELIF ( __crt_model = 3)
91    001F                  EXTERN  asm_dzx0_standard
92    001F                  call    asm_dzx0_standard
93    001F                ENDIF
94    001F              ENDIF
95    001F              
96    001F                  SECTION code_crt_init_exit
97    0000  C9              ret
98    0001                  SECTION code_crt_exit
99    0000              crt0_exit:
100   0000                  ; Teardown code can go here
101   0000                  SECTION code_crt_exit_exit
102   0000  C9              ret
103   0001              
104   0001                  SECTION bss_crt
105   0000              IF CRT_ENABLE_STDIO = 1
106   0000                  PUBLIC	__sgoioblk
107   0000                  PUBLIC	__sgoioblk_end
108   0000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0060  00 00 00 00 
                        __sgoioblk:     defs    CLIB_FOPEN_MAX * 10      ;stdio control block
109   0064              __sgoioblk_end:   		 ;end of stdio control block
110   0064              ENDIF
111   0064              
112   0064              
113   0064              
114   0064              
115   0064              IF !DEFINED_basegraphics
116   0064                  PUBLIC	base_graphics
117   0064  00 00       base_graphics:   defw    0       ;Address of graphics map
118   0066              ENDIF
119   0066                  PUBLIC	exitsp
120   0066                  PUBLIC	exitcount
121   0066  00 00       exitsp:          defw    0       ;atexit() stack
122   0068  00          exitcount:       defb    0       ;Number of atexit() routines
123   0069              IF DEFINED_USING_amalloc
124   0069                  PUBLIC _heap
125   0069                  ; The heap pointer will be wiped at startup,
126   0069                  ; but first its value (based on __tail)
127   0069                  ; will be kept for sbrk() to setup the malloc area
128   0069              _heap:
129   0069                  defw 0          ; Initialised by code_crt_init - location of the last program byte
130   0069                  defw 0
131   0069              ENDIF
132   0069              
133   0069              IF CLIB_BALLOC_TABLE_SIZE > 0
134   0069              
135   0069                 ; create balloc table
136   0069                 SECTION data_alloc_balloc
137   0069                 PUBLIC __balloc_array
138   0069                 __balloc_array:             defw __balloc_table
139   0069              
140   0069                 SECTION bss_alloc_balloc
141   0069                 PUBLIC __balloc_table
142   0069                 __balloc_table:             defs CLIB_BALLOC_TABLE_SIZE * 2
143   0069              
144   0069              ENDIF
145   0069              
242   0069                  INCLUDE "crt/classic/crt_cpm_fcntl.asm"
1     0069              ; CP/M style FCB support (CP/M + MSXDOS1)
2     0069              
3     0069              
4     0069              
5     0069              
6     0069              
7     0069                  SECTION bss_crt
8     0069              
9     0069              IF CLIB_OPEN_MAX > 0
10    0069                  SECTION bss_crt
11    0069                  PUBLIC  __fcb
12    0069              __fcb:
13    0069  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0089  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      00A9  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      00C9  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      00E9  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0109  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0129  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0149  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0169  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0189  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      01A9  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      01C9  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      01E9  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0209  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0229  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0249  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
                            defs    CLIB_OPEN_MAX * 166	; Each FCB is 43 bytes long
14    025B              ENDIF
15    025B              
16    025B                  PUBLIC  defltdsk
17    025B  00          defltdsk:       defb    0	;Default disc
18    025C              
243   025C              
244   025C                  SECTION code_crt_init
245   001F  0E 19           ld      c,25
246   0021  CD 05 00        call    5
247   0024  32 5B 02        ld      (defltdsk),a
248   0027              
249   0027              
250   0027              
